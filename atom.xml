<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[GKK]]></title>
  <link href="https://mokai.me/atom.xml" rel="self"/>
  <link href="https://mokai.me/"/>
  <updated>2018-01-18T00:21:59+08:00</updated>
  <id>https://mokai.me/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[记一次Theos开发Tweak]]></title>
    <link href="https://mokai.me/15162018706319.html"/>
    <updated>2018-01-17T23:11:10+08:00</updated>
    <id>https://mokai.me/15162018706319.html</id>
    <content type="html"><![CDATA[
<p>最近在看《iOS逆向工程》，本篇是对Theos安装以及部署deb安装包到手机上的记录以及安装过程中遇到的坑。</p>

<span id="more"></span><!-- more -->

<h5 id="toc_0">安装Theos</h5>

<p>书中有些步骤已经失效，所以我们按照官方安装<a href="https://github.com/theos/theos/wiki/Installation">Wiki</a>来</p>

<ul>
<li>安装ldid</li>
</ul>

<pre><code>brew install ldid dpkg-deb
sudo cpan IO::Compress::Lzma
</code></pre>

<ul>
<li>安装Theos</li>
</ul>

<p>把THEOS路径写进<code>~/.bash_profile</code>末尾</p>

<pre><code class="language-shell">THEOS=/opt/theos
PATH=${PATH}:${THEOS}/bin
</code></pre>

<blockquote>
<p>官方默认是放在<code>~/theos</code>下，但安装过程发现，在这个目录下会报错</p>
</blockquote>

<pre><code>&lt;built-in&gt;:1:10: error: non-portable path to file
      &#39;&quot;/UUsersGgkkttheosPPrefix.pch&quot;&#39;; specified path differs in case from file
      name on disk [-Werror,-Wnonportable-include-path]
#include &quot;/Users/GKK/theos/Prefix.pch&quot;
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         &quot;/UUsersGgkkttheosPPrefix.pch&quot;
1 error generated.
make[3]: *** [/Users/GKK/Desktop/test/.theos/obj/debug/armv7/Tweak.xm.7a3a1d98.o] Error 1
make[2]: *** [/Users/GKK/Desktop/test/.theos/obj/debug/armv7/Test.dylib] Error 2
make[1]: *** [internal-library-all_] Error 2
make: *** [Test.all.tweak.variables] Error 2
</code></pre>

<p>下载Theos到<code>$THEOS</code>位置，依次执行以下命令</p>

<pre><code class="language-shell">git clone --recursive https://github.com/theos/theos.git $THEOS
sudo chown -R $(id -u):$(id -g) $THEOS
curl https://ghostbin.com/ghost.sh -o $THEOS/bin/ghost
chmod +x $THEOS/bin/ghost
</code></pre>

<h4 id="toc_1">生成tweak模板</h4>

<p>通过nic.pl命令生成tweak项目</p>

<pre><code class="language-shell">GKK:test $ nic.pl
NIC 2.0 - New Instance Creator
------------------------------
  [1.] iphone/activator_event
  [2.] iphone/application_modern
  [3.] iphone/cydget
  [4.] iphone/flipswitch_switch
  [5.] iphone/framework
  [6.] iphone/ios7_notification_center_widget
  [7.] iphone/library
  [8.] iphone/notification_center_widget
  [9.] iphone/preference_bundle_modern
  [10.] iphone/tool
  [11.] iphone/tweak
  [12.] iphone/xpc_service
Choose a Template (required):
</code></pre>

<p>输入11生成tweak模板</p>

<pre><code class="language-shell">NIC 2.0 - New Instance Creator
------------------------------
  [1.] iphone/activator_event
  [2.] iphone/application_modern
  [3.] iphone/cydget
  [4.] iphone/flipswitch_switch
  [5.] iphone/framework
  [6.] iphone/ios7_notification_center_widget
  [7.] iphone/library
  [8.] iphone/notification_center_widget
  [9.] iphone/preference_bundle_modern
  [10.] iphone/tool
  [11.] iphone/tweak
  [12.] iphone/xpc_service
Choose a Template (required): 11
Project Name (required):
</code></pre>

<p>项目名字，我们这里输入Hello，接下来全部按回车即可。</p>

<pre><code class="language-shell">NIC 2.0 - New Instance Creator
------------------------------
  [1.] iphone/activator_event
  [2.] iphone/application_modern
  [3.] iphone/cydget
  [4.] iphone/flipswitch_switch
  [5.] iphone/framework
  [6.] iphone/ios7_notification_center_widget
  [7.] iphone/library
  [8.] iphone/notification_center_widget
  [9.] iphone/preference_bundle_modern
  [10.] iphone/tool
  [11.] iphone/tweak
  [12.] iphone/xpc_service
Choose a Template (required): 11
Project Name (required): HelloTweak
Package Name [com.yourcompany.hellotweak]:
Author/Maintainer Name [GKK]:
[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]:
[iphone/tweak] List of applications to terminate upon installation (space-separated, &#39;-&#39; for none) [SpringBoard]:
Instantiating iphone/tweak in hellotweak/...
Adding &#39;HelloTweak&#39; as an aggregate subproject in Theos makefile &#39;Makefile&#39;.
Done.
</code></pre>

<h5 id="toc_2">编写Tweak</h5>

<p>在生成的hellotweak目录下的Tweak.xm写入</p>

<pre><code>%hook SpringBoard
- (void)applicationDidFinishLaunching:(id)applicaton
{
    %orig;
    
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle: @&quot;Hello Tweak&quot; message: nil delegate: self cancelButtonTitle:@&quot;Cool&quot; otherButtonTitles: nil];
    [alert show];
    [alert release];
}
%end
</code></pre>

<p>大概就是在SpringBoard这个系统APP上hook<code>applicationDidFinishLaunching</code>方法，也就是<code>Method swizzling</code>，通过<code>%orig</code>调用原先的方法。</p>

<h4 id="toc_3">安装到已越狱设备上</h4>

<ul>
<li><p>安装SSH</p>

<p>通过设备上的Cydia安装<code>OpenSSH</code>，在设置-WIFI中找到当前WIFI的IP地址。<br/>
在电脑上通过<code>ssh root@这里填设备的IP</code>来连接，默认的密码是<code>alpine</code></p></li>
<li><p>安装tweak</p>

<p>首先在Tweak项目目录下的Makefile中最上面加入<code>THEOS_DEVICE_IP = 这里填设备的IP</code></p>

<p>最后一步，在命令行输入<code>make package install</code>，在输入两次SSH root密码后，SpringBoard重启将看到Alter。</p>

<blockquote>
<p>如果安装这里提示<code>substrate</code>相关报错，建议在<code>Cydia</code>中重新安装下<code>Substrate</code>就好了</p>
</blockquote></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS实现夜间模式]]></title>
    <link href="https://mokai.me/theme.html"/>
    <updated>2017-09-27T05:25:54+08:00</updated>
    <id>https://mokai.me/theme.html</id>
    <content type="html"><![CDATA[
<p>本文实现思路主要参考了<a href="https://www.zhihu.com/question/25072411">这里</a>，大概就是为日间模式与夜间模式各提供一份资源文件，资源文件中包含颜色值与图标名，切换主题加载相应主题的资源并刷新页面的控件即可，这和实现国际化有点类似。</p>

<span id="more"></span><!-- more -->

<p><img src="media/15064611549268/theme_demo.gif" alt="theme_demo"/></p>

<p><a href="https://github.com/mokai/ThemeDemo">附带Demo</a></p>

<h4 id="toc_0">定义资源文件</h4>

<p>首先定义资源文件，我们使用JSON做为配置的格式，大概如下：</p>

<pre><code class="language-json">{
    &quot;colors&quot;: {
        &quot;tint&quot;: &quot;#404146&quot;,
        &quot;background&quot;: &quot;#FFFFFF&quot;,
        &quot;text&quot;: &quot;#404146&quot;,
        &quot;placeholder&quot;: &quot;#AAAAAA&quot;,
        &quot;separator&quot;: &quot;#C8C7CC&quot;,
        &quot;shadow_layer&quot;: &quot;#00000026&quot;,
        &quot;tabBar_background&quot;: &quot;#FFFFFF&quot;,
        &quot;tabBar_normal&quot;: &quot;#8A8A8F&quot;,
        &quot;tabBar_selected&quot;: &quot;#404146&quot;,
        &quot;navigationBar_background&quot;: &quot;#FFFFFF&quot;,
        &quot;cell_background&quot;: &quot;#FFFFFF&quot;,
        &quot;cell_selected_background&quot;: &quot;#B8B8B8&quot;,
        &quot;switch_tint&quot;: &quot;#3F72AF&quot;
    },
    &quot;images&quot;: {
        &quot;article_loading&quot;: &quot;article_loading&quot;
    }
}
</code></pre>

<ul>
<li>colors 定义颜色值 </li>
<li><p>images 定义图片</p>

<blockquote>
<p>大多数情况下，我们可以把纯色图标的Render AS 设置为 Template Image 来满足不同颜色的渲染，对于不是纯色图标才使用多张图片来定义。</p>
</blockquote></li>
</ul>

<h4 id="toc_1">控件样式</h4>

<p>首先通用的样式，比如主题色、字体色、背景色等，页面上NavigationBar、UILabel、UIButton等控件基本都固定使用了这些样式，那么这部分我们就可以自动更新。</p>

<p>而需要自定义的 <code>属性样式</code>，我们通过扩展一系列key配置好属性样式名就行了，比如<code>backgroundColorKey</code>、<code>textColorKey</code>，而之后自动更新样式的过程就可以优先判断这些值是否不为空，否则就使用上面的通用样式。</p>

<pre><code class="language-swift">extension UILabel {
    
    /// 自动更新文本色的配置key
    @IBInspectable var textColorKey: String? {
        get {
            return objc_getAssociatedObject(self, &amp;ThemeUILabelTextColorKey) as? String
        }
        set {
            objc_setAssociatedObject(self, &amp;ThemeUILabelTextColorKey, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC)
        }
    }
    
}
</code></pre>

<h4 id="toc_2">主题管理类</h4>

<p>负责切换主题，获取相应主题的资源，并自动更新控件通用样式或者自定义的属性样式</p>

<ul>
<li>切换主题</li>
</ul>

<pre><code class="language-swift">/// 当前主题
fileprivate(set) var style: ThemeStyle {
    get {
        if let currentStyleString = df.string(forKey: ThemeCurrentStyle),
            let currentStyle = ThemeStyle(rawValue: currentStyleString)  {
            return currentStyle
        }
        return .default
    }
    set {
        df.set(newValue.rawValue, forKey: ThemeCurrentStyle)
        df.synchronize()
        //加载主题资源
        setup() 
        //通知现有页面更新
        NotificationCenter.default.post(name: .ThemeStyleChange, object: nil)
    }
}

/// 切换主题
func switchStyle() {
    style = style == .default ? .night : .default
}

</code></pre>

<ul>
<li>获取主题资源</li>
</ul>

<pre><code class="language-swift">let style = self.style //当前样式
        
//从应用Bundle中拿相应主题名.theme文件
let path = Bundle.main.path(forResource: style.rawValue, ofType: &quot;theme&quot;)!
let url = URL(fileURLWithPath: path)
let string = try! String(contentsOf: url)
let json = JSON(parseJSON: string)

self.colors = [:] 
self.images = [:]

//颜色
let colorsJSON = json[&quot;colors&quot;].dictionaryValue
colorsJSON.forEach { (key, value) in
    self.colors[key] = UIColor(value.stringValue)
}

//图片
let imagesJSON = json[&quot;images&quot;].dictionaryValue
imagesJSON.forEach { (key, value) in
    self.images[key] = value.stringValue
}
</code></pre>

<ul>
<li>自动更新样式</li>
</ul>

<pre><code class="language-swift">/// 自动更新到当前主题下的通用样式
///
/// - Parameter view: View
func updateThemeSubviews(with view: UIView) {
    guard view.autoUpdateTheme else { //不需要自动切换样式
        //更新subviews
        //UIButton中有UILabel，所以不需要更新subviews
        guard !(view is UIButton) else {
            return
        }
        view.subviews.forEach { (subView) in
            updateThemeSubviews(with: subView)
        }
        return
    }
    //各种视图更新
    if let tableView = view as? UITableView {
        //取消当前选择行
        if let selectedRow = tableView.indexPathForSelectedRow {
            tableView.deselectRow(at: selectedRow, animated: false)
        }
        tableView.backgroundColor = Theme.backgroundColor
        tableView.separatorColor = Theme.separatorColor
    }
    else if let cell = view as? UITableViewCell {
        cell.backgroundColor = Theme.cellBackgroundColor
        cell.contentView.backgroundColor = cell.backgroundColor
        cell.selectedBackgroundView?.backgroundColor = Theme.cellSelectedBackgroundColor
    }
    else if let collectionView = view as? UICollectionView {
        collectionView.backgroundColor = C.theme.backgroundColor
    }
    else if let cell = view as? UICollectionViewCell {
        cell.backgroundColor = Theme.cellBackgroundColor
        cell.selectedBackgroundView?.backgroundColor = Theme.cellSelectedBackgroundColor
    }
    else if let lab = view as? UILabel {
        if let key = lab.textColorKey {
            lab.textColor = self.color(forKey: key)
        } else {
            lab.textColor = Theme.textColor
        }
    }
    else if let btn = view as? UIButton {
        if let key = btn.titleColorKey {
            btn.setTitleColor(self.color(forKey: key), for: .normal)
        } else {
            btn.setTitleColor(Theme.textColor, for: .normal)
        }
        if let key = btn.selectedColorKey {
            btn.setTitleColor(self.color(forKey: key), for: .selected)
        }
    }
    else if let textField = view as? UITextField {
        if let key = textField.textColorKey {
            textField.textColor = self.color(forKey: key)
        } else {
            textField.textColor = Theme.textColor
        }
        if let key = textField.placeholderColorKey {
            textField.placeholderColor = self.color(forKey: key)
        }
    }
    else if let textView = view as? UITextView {
        if let key = textView.textColorKey {
            textView.textColor = self.color(forKey: key)
        } else {
            textView.textColor = Theme.textColor
        }
        //UITextView不能通过appearance设置keyboardAppearance，所以在此处设置
        let keyboardAppearance: UIKeyboardAppearance = self.style == .default ? .default : .dark
        textView.keyboardAppearance = keyboardAppearance
    }
    else if let imageView = view as? UIImageView {
        if let key = imageView.imageNamedKey {
            imageView.image = self.image(forKey: key)
        }
    }
    else if let switchView = view as? UISwitch {
        switchView.onTintColor = Theme.switchTintColor
    }
    else if let datePicker = view as? UIDatePicker {
        datePicker.setValue(Theme.textColor, forKey: &quot;textColor&quot;)
        datePicker.setValue(false, forKey: &quot;highlightsToday&quot;)
    }
    //主题色
    if let key = view.tintColorKey {
        view.tintColor = self.color(forKey: key)
    }
    //背景色
    if let key = view.backgroundColorKey {
        view.backgroundColor = self.color(forKey: key)
    }
    //更新subviews
    //UIButton中有UILabel，所以不需要更新subviews
    guard !(view is UIButton) else {
        return
    }
    view.subviews.forEach { (subView) in
        updateThemeSubviews(with: subView)
    }
}
</code></pre>

<p>其中<code>Theme.xxxColor</code>是扩展的getter属性，用于访问当前样式某个颜色值，建议自定义的颜色与图片也基于Theme扩展。</p>

<blockquote>
<p>由于自动更新过程就是对view递归设置，而该方法需要手动调用，调用时机一般是在viewDidLoad中或者收到<code>ThemeStyleChange</code>通知时。对于UITableView与UICollectionView中，通常会在cell的awakeFromNib中调用一次。</p>
</blockquote>

<h4 id="toc_3">BaseXXX</h4>

<p>切换样式后会通知<code>ThemeStyleChange</code>，我们在各种<code>BaseXXX</code>中调用<code>updateThemeSubviews</code>。</p>

<blockquote>
<p>使用<code>BaseXXX</code>基类的方式确实不优雅，在意的读者可以看下 <a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> 代码，它是基于NSObject扩展的，对业务代码耦合低，但遗憾没有<code>自动更新通用样式</code>功能。</p>
</blockquote>

<pre><code class="language-swift">class BaseVC: UIViewController {

    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        updateTheme()
        //监听主题改变通知
        NotificationCenter.default.addObserver(self, selector: #selector(self.onThemeChange), name: .ThemeStyleChange, object: nil)
    }
    
    @objc func onThemeChange() {
        UIView.animate(withDuration: 0.25) {
            self.updateTheme()
        }
    }
    
    /// 更新当前ViewController的主题
    func updateTheme() {
        if view.backgroundColorKey == nil {
            view.backgroundColor = Theme.backgroundColor //顶层View
        }
        Theme.shared.updateThemeSubviews(with: view)
    } 
}
</code></pre>

<p>其它BaseXXX直接套用以上的代码，放在updateTheme中就行了</p>

<p>BaseTabBarController</p>

<pre><code class="language-swift">tabBar.tintColor = Theme.tabBarSelectedColor
tabBar.barTintColor = Theme.tabBarBackgroundColor
tabBar.backgroundColor = Theme.tabBarBackgroundColor
tabBar.isTranslucent = false
if #available(iOS 10.0, *) {
    tabBar.unselectedItemTintColor = Theme.tabBarNormalColor
} else {
    UIView.performWithoutAnimation {
        self.viewControllers?.forEach({ (vc) in
            vc.tabBarItem.setTitleTextAttributes([NSAttributedStringKey.foregroundColor: Theme.tabBarNormalColor],
                                                 for: .normal)
            vc.tabBarItem.setTitleTextAttributes([NSAttributedStringKey.foregroundColor: Theme.tabBarSelectedColor],
                                                 for: .selected)
        })
    }
}
</code></pre>

<p>BaseNavigationController</p>

<pre><code class="language-swift">//背景
let bgImageSize = CGSize(width: view.frame.width, height: 64)
UIGraphicsBeginImageContext(bgImageSize)
Theme.navigationBarBackgroundColor.setFill()
UIGraphicsGetCurrentContext()!.fill(CGRect(origin: CGPoint(), size: bgImageSize))
let bgImage = UIGraphicsGetImageFromCurrentImageContext()
UIGraphicsEndImageContext()
navigationBar.setBackgroundImage(bgImage, for: .default)
navigationBar.backgroundColor = Theme.navigationBarBackgroundColor

navigationBar.barTintColor = Theme.textColor
navigationBar.tintColor = Theme.textColor
navigationBar.titleTextAttributes = [NSAttributedStringKey.foregroundColor: Theme.textColor]
UIBarButtonItem.appearance().tintColor = Theme.textColor
//已打开的页面使用appearance无效
viewControllers.forEach { (vc) in
    vc.navigationItem.backBarButtonItem?.tintColor = Theme.textColor
    vc.navigationItem.leftBarButtonItems?.forEach({ (item) in
        item.tintColor = Theme.textColor
    })
    vc.navigationItem.rightBarButtonItems?.forEach({ (item) in
        item.tintColor = Theme.textColor
    })
}
</code></pre>

<p>BaseXXXCell</p>

<pre><code class="language-swift">class BaseTableViewCell: UITableViewCell {
    override func awakeFromNib() {
        super.awakeFromNib()
        if selectionStyle != .none {
            selectedBackgroundView = UIView(frame: frame)
        }
        Theme.shared.updateThemeSubviews(with: self)
    }
}
</code></pre>

<p>这里没有监听<code>ThemeStyleChange</code>通知是因为自动更新的过程会更新到TableView下所有可见的UITableViewCell，当然不可见的UITableViewCell也需要更新，我们可以用以下代码手动更新</p>

<pre><code class="language-swift">if let dataSource = tableView.dataSource {
    let sectionNumber = dataSource.numberOfSections?(in: tableView) ?? tableView.numberOfSections
    for section in 0..&lt;sectionNumber {
        for row in 0..&lt;dataSource.tableView(tableView, numberOfRowsInSection: section) {
            let cell = dataSource.tableView(tableView, cellForRowAt: IndexPath(row: row, section: section))
            Theme.shared.updateThemeSubviews(with: cell)
        }
    }
}
</code></pre>

<p>Cell的Selection不可以设置颜色，我们通过自定义<code>selectedBackgroundView</code>来实现，在自动更新的过程中设置<code>cell.selectedBackgroundView.backgroundColor</code>。<br/>
另外如果TableView处于选中状态，选中行的selectedBackgroundView会为nil，我们在设置前先<code>deselectRow</code>。</p>

<h4 id="toc_4">web页面夜间模式</h4>

<p>由于css样式优先级的机制，最新的样式可覆盖旧的样式，所以我们只需要为每种样式添加一种夜间模式样式就行。</p>

<pre><code class="language-css">/*夜间模式样式*/
.night-mode {
    background-color: #333333;
}
.night-mode #articleCon p,
.night-mode #articleCon ol li,
.night-mode #articleCon ul li {
    color: #CDCDCD;
}
</code></pre>

<p>在原生端切换样式时，通过JS函数把夜间模式的css附加上去就行了，切换回默认主题删除样式即可。</p>

<pre><code class="language-js">//JS代码

//切换至夜间模式
Enclave.switchToNightMode = function() {
    document.querySelector(&#39;html&#39;).classList.add(&#39;night-mode&#39;)
}

//切换至白天模式
Enclave.switchToLightMode = function() {
    document.querySelector(&#39;html&#39;).classList.remove(&#39;night-mode&#39;)
}
</code></pre>

<h4 id="toc_5">细节</h4>

<ul>
<li><p><code>UIApplication.shared.statusBarStyle</code>设置</p>

<p>iOS默认不可以通过<code>UIApplication.shared.statusBarStyle</code>设置样式，需要info.plist中把<code>UIViewControllerBasedStatusBarAppearance</code>设置为false</p></li>
<li><p>设置UIPickerView文字颜色</p></li>
</ul>

<pre><code class="language-swift">func pickerView(_ pickerView: UIPickerView, attributedTitleForRow row: Int, forComponent component: Int) -&gt; NSAttributedString? { 
    let string = self.dataSource[row]
    return NSAttributedString(string: string, attributes: [NSForegroundColorAttributeName: C.theme.textColor])
}
</code></pre>

<ul>
<li>设置UIDatePicker文字颜色</li>
</ul>

<pre><code class="language-swift">datePicker.setValue(C.theme.textColor, forKey: &quot;textColor&quot;)
datePicker.setValue(false, forKey: &quot;highlightsToday&quot;) //取消datePicker.date当前日期高亮
</code></pre>

<ul>
<li>UITextView通过appearance设置keyboardAppearance会crash
切换到夜间主题时可能需要把keyboardAppearance设置为<code>UIKeyboardAppearance.dark</code></li>
</ul>

<pre><code class="language-swift">let keyboardAppearance: UIKeyboardAppearance = style == .default ? .default : .dark
UITextField.appearance().keyboardAppearance = keyboardAppearance
</code></pre>

<p>但以上代码应用在UITextView会Crash，暂不知道什么原因造成的，有同学知道可以告诉下。<br/>
所以对于UITextView的keyboardAppearance我们需要通过实例设置</p>

<pre><code class="language-swift">let keyboardAppearance: UIKeyboardAppearance = style == .default ? .default : .dark
textView.keyboardAppearance = keyboardAppearance
</code></pre>

<p>文中有何错误还望指教~</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读类APP涉及的技术]]></title>
    <link href="https://mokai.me/read-app-knowledge.html"/>
    <updated>2017-12-19T21:00:20+08:00</updated>
    <id>https://mokai.me/read-app-knowledge.html</id>
    <content type="html"><![CDATA[
<p><a href="https://itunes.apple.com/cn/app/%E9%A3%9E%E5%9C%B0-%E6%96%87%E8%89%BA%E9%9D%92%E5%B9%B4%E7%9A%84%E9%AB%98%E5%93%81%E8%B4%A8%E6%96%87%E5%AD%A6%E8%89%BA%E6%9C%AF%E9%98%85%E8%AF%BB%E7%A4%BE%E5%8C%BA/id1179249797?mt=8">飞地</a>是一款诗歌<code>轻阅读</code>产品，在技术选型时内容的载体采用了HTML，这样内容可以适用于全平台显示。</p>

<blockquote>
<p>轻阅读是从技术角度分析的，因为没有像微信读书这类应用有长篇文字的书籍，需要实现各种PDF和ePub格式解析以及排版，我们只需要用UIWebView即可解决。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>首先<code>内容</code>是<code>body</code>中的一段HTML，通过接口拿到文章的<code>内容</code>后替换到完整的HTML模板中</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; &gt;
        {css}
    &lt;/head&gt;    
    &lt;body id=&#39;articleCon&#39;&gt;
        {body}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><code>{css}</code>是内容的样式，如标题、段落、脚注等，<code>articleCon</code>是为了样式选择器。</p>

<blockquote>
<p>css来源有二种情况，启动时加载服务器最新的，如果失败则使用本地的备份css</p>
</blockquote>

<p>最后使用<code>loadHTMLString</code>来加载替换后的HTML。</p>

<h4 id="toc_0">页面结构</h4>

<p>飞地有几个内容模块都是基于HTML来做为内容的载体，但页面一般不只是纯内容，会有一些其它元数据，这些使用原生视图显示。</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/15140228637358.jpg" alt=""/></p>

<p>如上图文章详情页，整个页面的容器是<code>UITableView</code>，封面图、作者、日期、内容WebView都是tableHeaderView，评论列表为Cell。</p>

<p>tableHeaderView的高度我们需要自己计算，而WebView的高度可以在webViewDidFinishLoad后获取，并重新设置tableHeaderView的高度。</p>

<pre><code class="language-swift">//原生代码

var contentHeight = webView.scrollView.contentSize.height
let fitHeight = webView.sizeThatFits(CGSize(width: 1.0, height: 1.0)).height
if fitHeight &gt; contentHeight {
    contentHeight = fitHeight
}
if let documentHeight = jsBridge.getContentHeight(),
    documentHeight &gt; contentHeight {
    contentHeight = documentHeight
}
</code></pre>

<p><code>jsBridge.getContentHeight()</code>是执行JS层的代码<code>document.body.scrollHeight * window.scale</code>获取高度</p>

<blockquote>
<p>Tip：直接设置<code>tableView.tableHeaderView.frame.height</code>时可能不会生效，需要重新<code>tableView.tableHeaderView = tableHeaderView</code>渲染一次。</p>
</blockquote>

<h4 id="toc_1">rem</h4>

<p>文章有各种各样的样式，移动设备碎片化，使用px明显已经不满足需求了，所以我们使用rem。</p>

<pre><code class="language-html">//JS代码

window.scale = 1.0; //标志当前viewport使用的scale
!function(e){function t(a){if(i[a])return i[a].exports;var n=i[a]={exports:{},id:a,loaded:!1};return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports}var i={};return t.m=e,t.c=i,t.p=&quot;&quot;,t(0)}([function(e,t){&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,{value:!0});var i=window;t[&quot;default&quot;]=i.flex=function(normal,e,t){var a=e||100,n=t||1,r=i.document,o=navigator.userAgent,d=o.match(/Android[\S\s]+AppleWebkit\/(\d{3})/i),l=o.match(/U3\/((\d+|\.){5,})/i),c=l&amp;&amp;parseInt(l[1].split(&quot;.&quot;).join(&quot;&quot;),10)&gt;=80,p=navigator.appVersion.match(/(iphone|ipad|ipod)/gi),s=i.devicePixelRatio||1;p||d&amp;&amp;d[1]&gt;534||c||(s=1);var u=normal?1:1/s,m=r.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;);m||(m=r.createElement(&quot;meta&quot;),m.setAttribute(&quot;name&quot;,&quot;viewport&quot;),r.head.appendChild(m)),m.setAttribute(&quot;content&quot;,&quot;width=device-width,user-scalable=no,initial-scale=&quot;+u+&quot;,maximum-scale=&quot;+u+&quot;,minimum-scale=&quot;+u),i.scale=u,r.documentElement.style.fontSize=normal?&quot;50px&quot;: a/2*s*n+&quot;px&quot;},e.exports=t[&quot;default&quot;]}]); flex(false,100, 1);
</code></pre>

<pre><code class="language-css">html {
    font-size: 62.5%;
}
</code></pre>

<p>上述代码分别加在文章内容HTML模板中与文章css中，而飞地的设计图输出是<code>375pt * 667pt</code>，所以我们只需要把设计上的<code>pt/50</code>转换成rem就行了(<code>50是设备缩放基准值</code>)，如设计图上的正文字体是<code>17pt</code>，那么对应css的rem应该是 <code>17pt /50 = 0.34rem</code></p>

<pre><code>#articleCon n p {
    font-size: 0.34rem;
}
</code></pre>

<h4 id="toc_2">缓存</h4>

<p>由于有离线阅读需求，app启动时会提前缓存文章，其实也就是存储文章的封面图、内容HTML等，但html中也有图片，所以我们需要用<code>正则</code>拿到所有<code>img.src</code>，然后缓存在本地，并将文章标识为已缓存。</p>

<pre><code>&lt;img\\s[\\s\\S]*?src\\s*?=\\s*?[&#39;\&quot;](.*?)[&#39;\&quot;][\\s\\S]*?&gt;*
</code></pre>

<p>前期我们采用的方式是将所有<code>img.src</code>保持相对路径，<code>loadHTMLString</code>时如果文章标识已缓存则baseURL使用本地Path，否则使用线上URL。</p>

<p>优化后统一换成<code>URLProtocol</code>处理，提前缓存文章时用<code>第三方图片加载库</code>下载好图片，等阅读文章时利用<code>URLProtocol</code>机制拦截，如果是WebView的图片，判断该图片是否缓存在<code>第三方图片加载库</code>中，否则手动加载图片Data并且保存在<code>第三方图片加载库</code>，下次再拦截到此图片的请求直接从<code>第三方图片加载库</code>缓存中取。</p>

<blockquote>
<p><code>URLProtocol</code>是全局拦截，判断请求是否为WebView的图片可在<code>shouldStartLoadWith</code>时附加自定义Header，在<code>URLProtocol</code>识别Header就行</p>
</blockquote>

<h4 id="toc_3">原生与JS交互</h4>

<p>有二种方式，原生提供的JavaScriptCore、JS层通过iFrame加载URI（URI包括scheme与参数）原生在<code>shouldStartLoadWith</code>中拦截，飞地使用了第一种。</p>

<pre><code class="language-swift">//原生代码

/// 原生JavaScriptCore暴露给JS层的对象
@objc protocol ContentWebViewJavaScriptBridgeProtocol: JSExport {
    
    /// 图片点击回调
    func onImageClick(_ currentImageIndex: Int, _ images: [String])
    
}

/// 原生与JS桥接
class ContentWebViewJavaScriptBridge: NSObject, ContentWebViewJavaScriptBridgeProtocol {
    //原生暴露给JS层的对象名
    static let name = &quot;EnclaveNative&quot;
    fileprivate var jsContext: JSContext?
    fileprivate weak var webView: UIWebView?
    
    var imageClickCallback: ((_ currentImageIndex: Int, _ images: [String])-&gt;())?
    
    convenience init(webView: UIWebView) {
        self.init()
        guard let jsContext = webView.value(forKeyPath: &quot;documentView.webView.mainFrame.javaScriptContext&quot;) as? JSContext else { return }
        self.jsContext = jsContext
        self.webView = webView
        jsContext.setObject(self, forKeyedSubscript: ContentWebViewJavaScriptBridge.name as NSCopying &amp; NSObjectProtocol)
        
        jsContext.exceptionHandler = { (ctx, value) in
            L.debug(value?.description ?? &quot;exception&quot;)
        }
    }
    
    func onImageClick(_ currentImageIndex: Int, _ images: [String]) {
        //回调在UI线程
        DispatchQueue.main.async {
            self.imageClickCallback?(currentImageIndex, images)
        }
    }
}

//MARK: - Public
extension ContentWebViewJavaScriptBridge {
    
    /// 获取html中所有图片地址
    func getImages() -&gt; [String]? {
        guard let jsContext = jsContext else { return nil }
        
        guard let jsValue = jsContext.evaluateScript(&quot;getImageSrcs()&quot;) else { return nil }
        return jsValue.toArray() as? [String]
    }
    
    /// 获取内容高度
    func getContentHeight() -&gt; CGFloat? {
        if let heightString = webView?.stringByEvaluatingJavaScript(from: &quot;Enclave.getContentHeight()&quot;),
            let height = Float(heightString) {
            return CGFloat(height)
        }
        return nil
    }
    
    /// 切换主题
    func switchTheme() {
        if ELThemeManager.shared.style == .night {
            switchToNightMode()
        } else {
            switchToLightMode()
        }
    }
    
    /// 切换至夜间模式
    fileprivate func switchToNightMode() {
        webView?.stringByEvaluatingJavaScript(from: &quot;Enclave.switchToNightMode()&quot;)
    }
    
    /// 切换至日间模式
    fileprivate func switchToLightMode() {
        webView?.stringByEvaluatingJavaScript(from: &quot;Enclave.switchToLightMode()&quot;)
    }
}

</code></pre>

<ul>
<li>JS -&gt; 原生</li>
</ul>

<pre><code class="language-js">EnclaveNative.onImageClick(currentImageIndex, srcs)
</code></pre>

<ul>
<li>原生 -&gt; JS</li>
</ul>

<pre><code class="language-swift">webView.stringByEvaluatingJavaScript(from: &quot;xxx()&quot;)
</code></pre>

<h4 id="toc_4">图片查看</h4>

<p>点击内容HTML中的图片，需要在原生端显示查看。<br/>
首先在DOM加载完毕后为所有的有效img注册click事件，在事件触发时拿到所有img.src与当前img的index传到原生端并显示。</p>

<pre><code class="language-js">//JS代码

function getImageSrcs() {
    var srcs = []
    var imgs = document.getElementsByTagName(&#39;img&#39;)
    for (var i = 0; i &lt; imgs.length; i++) {
        if(imgs[i].src.indexOf(&#39;data:&#39;) == 0 || imgs[i].parentNode.nodeName.toLocaleLowerCase() == &#39;a&#39;) {
            continue
        }
        srcs.push(imgs[i].src)
    }
    return srcs
}

function onImageClick(currentImageIndex) {
    var srcs = getImageSrcs()
    //原生回调
    EnclaveNative.onImageClick(currentImageIndex, srcs)
}

function didload() {
    var imgs = document.getElementsByTagName(&#39;img&#39;)
    //有效图片index，因为可能会存在可跳转的图片
    var index = 0
    for (var i = 0; i &lt; imgs.length; i++) {
        //加载失败时默认图，且不可点击
        if(imgs[i].naturalWidth == &quot;undefined&quot; || imgs[i].naturalWidth == 0) {
            imgs[i].src = &#39;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAYEBAQFBAYFBQYJBgUGCQsIBgYICwwKCgsKCgwQDAwMDAwMEAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBwcHDQwNGBAQGBQODg4UFA4ODg4UEQwMDAwMEREMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIADIAZAMBEQACEQEDEQH/xABLAAEBAAAAAAAAAAAAAAAAAAAACBABAAAAAAAAAAAAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AoQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH//Z&#39;
        }
        //并图片本身包含链接时也不可点击
        if(imgs[i].parentNode.nodeName.toLocaleLowerCase() == &#39;a&#39;) {
            continue
        }
        imgs[i].imageIndex = index++ //给img元素设置一个index
        imgs[i].onclick = function(e) {
            onImageClick(e.target.imageIndex) //拿当前事件的元素index然后回调
        }
    }
}

window.addEventListener(&#39;load&#39;, function() {
    didload()
}, false)
</code></pre>

<h4 id="toc_5">夜间模式</h4>

<p><a name="light-mode"></a><br/>
关于原生iOS端实现夜间模式可查看<a href="">这里</a>，这里主要讲述web页面实现。<br/>
由于css样式优先级的机制，最新的样式可覆盖旧的样式，所以我们只需要为每种样式添加一种夜间模式样式就行。</p>

<pre><code class="language-css">/*夜间模式样式*/
.night-mode {
    background-color: #333333;
}
.night-mode #articleCon p,
.night-mode #articleCon ol li,
.night-mode #articleCon ul li {
    color: #CDCDCD;
}
</code></pre>

<p>在原生端切换样式时，通过JS函数把夜间模式的css附加上去就行了，切换回默认主题删除样式即可。</p>

<pre><code class="language-js">//JS代码

//切换至夜间模式
Enclave.switchToNightMode = function() {
    document.querySelector(&#39;html&#39;).classList.add(&#39;night-mode&#39;)
}

//切换至白天模式
Enclave.switchToLightMode = function() {
    document.querySelector(&#39;html&#39;).classList.remove(&#39;night-mode&#39;)
}
</code></pre>

<h4 id="toc_6">参考</h4>

<p><a href="https://github.com/amfe/article/issues/17">使用Flexible实现手淘H5页面的终端适配</a></p>

<p>有何错误还望指教，谢谢~</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MacBook Air内置显示器旋转Bug]]></title>
    <link href="https://mokai.me/15136777080241.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/15136777080241.html</id>
    <content type="html"><![CDATA[
<p>昨天双11买了台DELL的显示器，晚上到了之后兴奋地想体验下竖屏撸码，于是在Air的桌面操作了 <code>设置 -&gt; 显示器 -&gt; 缩放 -&gt; 旋转90度</code>（注意，我操作的是Air的桌面显示器设置，应该操作外接显示器中显示的窗口），之后外接显示屏没有旋转，Air的桌面旋转了，于是就悲剧了，退出设置后重新点显示器，显示 <code>未能载入偏好设置面板 显示器</code>错误，此时Air屏幕也是旋转的，如下。。。。</p>

<span id="more"></span><!-- more -->

<p><img src="media/15136777080241/macbook_rotate_bug.jpg" alt="macbook_rotate_bug" style="width:540px;"/></p>

<p><img src="media/15136777080241/macbook_rotate_bug2.png" alt="macbook_rotate_bug2"/></p>

<p>最后准备重装系统时，在<a href="http://tieba.baidu.com/p/3610507120">这里</a>了解到可以依赖软件手动旋转回来，使用<a href="http://soft.macx.cn/5906.htm">Pivot</a>即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3D Touch大法]]></title>
    <link href="https://mokai.me/3d-touch.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/3d-touch.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Demo同步更新到Swift2.3</p>
</blockquote>

<p>3D Touch最先应用在Apple Watch上面，但叫<code>Force Touch</code>，后在iPhone6s上加入了此特性，并改名3D Touch。值得注意的是目前3D Touch只支持iPhone6S以后的机型，包括现有Xcode7中6s的模拟器也不支持，不过Github上的<a href="https://github.com/DeskConnect/SBShortcutMenuSimulator">SBShortcutMenuSimulator</a>项目通过Hack方式已经实现了<code>Quick Actions</code>快捷访问，但不能使用<code>Peek&amp;Pop</code>快速预览。</p>

<span id="more"></span><!-- more -->

<p>如果你还不知道3D Touch是什么，可以看看官方宣传视频<br/>
<video src="http://images.apple.com/media/us/iphone-6s/2015/dhs3b549_75f9_422a_9470_4a09e709b350/films/feature/iphone6s-feature-cc-us-20150909_r848-9dwc.mov" controls ><br/>
</video></p>

<h3 id="toc_0">环境</h3>

<p>系统环境: iOS9 or later</p>

<p>开发环境: Swift2.3 &amp; Xcode7.3.1 </p>

<p>Demo: <a href="https://github.com/mokai/3DTouchDemo">3DTouchDemo</a></p>

<p>效果：<br/>
<video src="http://7xiew0.com1.z0.glb.clouddn.com/3dtouch.mov" controls width=320 ><br/>
</video></p>

<h3 id="toc_1">开始</h3>

<p>3D Touch可以分为三种：</p>

<ul>
<li>Quick Actions【可以理解PC桌面的快捷方式】</li>
<li>Peek&amp;Pop【应用内快速预览内容】</li>
<li>UITouch【自定义3D Touch事件】</li>
</ul>

<h3 id="toc_2">Quick Actions 快捷方式</h3>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/3dtouch_homeshorctquickactions.gif" alt=""/></p>

<p>配置Actions可以通过工程<code>Info.plist</code>文件静态配置，也可以在运行时动态添加，两者可以一起使用。</p>

<p>静态配置在<code>Info.plist</code>中<code>UIApplicationShortcutItems</code>节点数组下添加相应Actions Item信息</p>

<pre><code>&lt;key&gt;UIApplicationShortcutItems&lt;/key&gt;
&lt;array&gt;
    &lt;dict&gt;
        &lt;key&gt;UIApplicationShortcutItemIconType&lt;/key&gt;
        &lt;string&gt;UIApplicationShortcutIconTypeSearch&lt;/string&gt;
        &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt;
        &lt;string&gt;搜索&lt;/string&gt;
        &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt;
        &lt;string&gt;me.mokai.TouchDemo.action.search&lt;/string&gt;
    &lt;/dict&gt;
    ...
&lt;/array&gt;
</code></pre>

<p>动态配置通过UIApplication的<code>shortcutItems</code>添加，shortcutItems是一个<code>UIApplicationShortcutItem</code>数组</p>

<pre><code>let type = &quot;me.mokai.TouchDemo.action.identify&quot;
let title = &quot;听歌识别&quot;
let shortcutItem = UIApplicationShortcutItem(type: type, localizedTitle: title,
 localizedSubtitle: nil, icon: UIApplicationShortcutIcon(templateImageName: &quot;quick_filter&quot;), userInfo: nil)
application.shortcutItems = [shortcutItem]
</code></pre>

<p><b>Note</b></p>

<ul>
<li>Actions的图标可以使用系统预定的也可以自定义图片</li>
<li>对于每个Actions来说<code>type</code>是必须的，它代表着我们从桌面点击Actions进入到应用调用<code>application(application, performActionForShortcutItem:, completionHandler:)</code>时的唯一标识，另外userInfo可以附加每个actions的数据，如最近听歌的歌曲id</li>
<li>当APP启动时，shortcutItems的值是上次动态添加的，如果是第一次启动则为空数组。</li>
<li>Actions最多显示4个，优先显示静态Actions，然后剩余个数显示shortcutItems的前几个。</li>
</ul>

<h3 id="toc_3">Peek&amp;POP 快速预览</h3>

<p>好了，下面介绍本文重头戏，先上效果</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/3dtouch_peek.gif" alt=""/></p>

<p>Peek窗口的内容其实是目标VC【ps即将要显示的ViewController】的一个实时快照，但它不可以点击。Peek触发阶段有三种：</p>

<ul>
<li>长按【显示一个焦点视图，触发Peek的源视图高亮，其它视图都处于模糊状态】</li>
<li>轻压【显示Peek窗口，此时如果Peek窗口支持Quick Actions，往上滑会显示Quick Actions菜单，此时的Peek窗口是不可以点击的】</li>
<li>重压 【进入到真正的ViewController】</li>
</ul>

<p>Peek由一个<code>可响应事件的View</code>触发，默认是关闭的，我们需要通过控制器的<code>registerForPreviewingWithDelegate: sourceView:</code>方法注册，第一个参数为<code>UIViewControllerPreviewingDelegate</code>的代理，Peek触发轻压时会调用其<code>previewingContext:viewControllerForLocation</code>方法，重压时会调用<code>previewingContext:commitViewController:</code>方法。第二个参数为触发Peek事件的源视图</p>

<pre><code>//注册
registerForPreviewingWithDelegate(self, sourceView: userVCBtn)
</code></pre>

<pre><code>//Delegate
//轻压，进入第二阶段，显示Peek窗口
func previewingContext(previewingContext:  UIViewControllerPreviewing, viewControllerForLocation location:  CGPoint) -&gt; UIViewController? {
    let userVc = self.storyboard?.instantiateViewControllerWithIdentifier(&quot;UserViewController&quot;) as! UserViewController
    return userVc;
}
//重压，进入第三阶段，显示真正的ViewController
func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {
    showViewController(viewControllerToCommit, sender: self)
}
</code></pre>

<p>如果Peek窗口需要Quick Actions菜单，在目标VC中重写<code>previewActionItems</code>方法返回一个<code>UIPreviewActionItem</code>或者一个<code>UIPreviewActionGroup</code>数组就行了。</p>

<pre><code>//目标VC
lazy var previewActions: [UIPreviewActionItem] = {
    func previewActionForTitle(title: String, style:  UIPreviewActionStyle = .Default) -&gt; UIPreviewAction {
        return UIPreviewAction(title: title, style: style) { previewAction, viewController in
            print(&quot;点击了\(title)&quot;) //这里是Actions响应
        }
    }
    let action1 = previewActionForTitle(&quot;关注TA&quot;,style: .Destructive) //显示红色，代表重要Action
    let action2 = previewActionForTitle(&quot;私信TA&quot;)
    //子Actioons
    let subAction1 = previewActionForTitle(&quot;微博&quot;)
    let subAction2 = previewActionForTitle(&quot;好友圈&quot;)
    let subAction3 = previewActionForTitle(&quot;QQ&quot;)
    let subAction4 = previewActionForTitle(&quot;微信&quot;)
    let groupedActions = UIPreviewActionGroup(title: &quot;分享…&quot;, style: .Default, actions: [subAction1, subAction2, subAction3, subAction4] )
    return [action1, action2, groupedActions]
}()
override func previewActionItems() -&gt; [UIPreviewActionItem] {
    return previewActions
}
</code></pre>

<h4 id="toc_4">更快速的方法</h4>

<p>上面是代码激活Peek的方式，还有更Peek的方式：直接在Storyboard中使用Segue，在Segue属性面板中把Peek &amp; Pop 勾选上就完事了。</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/3dtouch_segue_peek.png.jpeg" alt=""/></p>

<p>使用这种方式指定我们在代码中连注册都不用，所以使用SB的项目适配3D Touch那是分分钟搞定的事，尤其在Xcode7出了<code>Storyboard References</code>后，我大 <code>Swift + Storyboard</code> 组合势必统一iOS界~</p>

<p>好了，有点小激动了，继续回到正文</p>

<p>在正常情况下，Peek窗口默认显示目标VC的整个View，但在实际应用中，可能会有更多的需求，比如说二个Button Push的是同一个VC，但是需要分别显示不同的Peek窗口。</p>

<p>其实也很简单，我们只需要自定义一个Peek的生命周期扩展就行了，<code>previewingContext:viewControllerForLocation:</code>方法中代表Peek的开始，<code>previewingContext:commitViewController</code>代表Peek的结束，然后在目标VC中重写二个方法就行了</p>

<pre><code>//UIViewController+PeekCycle.swift
/**
 Peek生命周期
**/
extension UIViewController {
    //开始peek，VC为Peek显示做初始化
    func beginPeek(){}
    //结束peek,VC为真正显示做初始化
    func endPeek(){}
}
</code></pre>

<pre><code>//Delegate
func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? {
    let detailVc = self.storyboard?.instantiateViewControllerWithIdentifier(&quot;DetailViewController&quot;) as! DetailViewController
    //指定Peek窗口类型
    detailVc.peekType = .Image
    //设置Peek的高度
    detailVc.preferredContentSize = CGSize(width: 0.0, height: 320);
    detailVc.view //先访问一下view，初始化
    detailVc.beginPeek() //peek开始
    return detailVc;
}
func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {
    viewControllerToCommit.endPeek()  //peek结束
    showViewController(viewControllerToCommit, sender: self)
}
</code></pre>

<pre><code>//目标VC
override func beginPeek() { 
    if(peekType == .Comments){ //如果是评论则只显示评论视图
        imageView.hidden = true
    }else{ //否则显示图片
        commentsView.hidden = true
    }
}
override func endPeek() {
    if(peekType == .Comments){
        imageView.hidden = false
    }else{
        commentsView.hidden = false
    }
}
</code></pre>

<p><b>Note</b></p>

<ul>
<li>如果要改变Peek窗口的size可以设置目标VC的<code>preferredContentSize</code></li>
<li>对于直接使用<code>registerForPreviewingWithDelegate</code>注册VC的self.view，虽然可以自动注册subviews，但是如果说你的VC中不止一种视图要触发Peek，那么它会分分钟教你做人的道理。</li>
</ul>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/funny_nonono.gif" alt=""/></p>

<h3 id="toc_5">UITouch</h3>

<p>高级玩法，绘图、游戏，把3D Touch发挥到极致。不过我也唔知玩也暂时没这方面需求，有需求看<a href="https://developer.apple.com/library/prerelease/ios/samplecode/TouchCanvas/">官方绘图demo</a></p>

<h3 id="toc_6">参考</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/">Adopting 3D Touch on iPhone</a></p>

<p><a href="https://developer.apple.com/library/ios/samplecode/ApplicationShortcuts/Introduction/Intro.html#//apple_ref/doc/uid/TP40016545">ApplicationShortcuts Demo</a></p>

<p><a href="https://developer.apple.com/library/ios/samplecode/ViewControllerPreviews/Introduction/Intro.html#//apple_ref/doc/uid/TP40016546">ViewControllerPreviews Demo</a></p>

<h3 id="toc_7">小小广告</h3>

<p>本人目前是一名自由职业者，接受移动两端的项目开发，如果你有需求或者有资源请速与我联系吧，QQ865425695</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#技巧4# 设置statusBarStyle无效]]></title>
    <link href="https://mokai.me/15136777080181.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/15136777080181.html</id>
    <content type="html"><![CDATA[
<p>新的一个APP，需要设置状态栏为白色，无论通过代码设置<code>UIApplication.sharedApplication().statusBarStyle = .LightContent</code> <br/>
还是直接在 <code>TARGETS</code> 中设置，发现都无效。</p>

<p><img src="http://i.stack.imgur.com/NoSiZ.png" alt=""/></p>

<p>我们只需要把<code>Info.plist</code>中的<code>View controller-based status bar appearance</code>改为NO就行了，默认为YES</p>

<h4 id="toc_0">参考:</h4>

<p><a href="http://stackoverflow.com/questions/26372684/ios8-set-the-status-bar-to-light-content">(iOS8) set the status bar to light content</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#技巧3# postNotificationName触发后的监听代码是同步还是异步执行的？]]></title>
    <link href="https://mokai.me/15136777080497.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/15136777080497.html</id>
    <content type="html"><![CDATA[
<p>昨天去酷狗面试，被问到<code>postNotificationName触发后的监听代码是同步还是异步执行的？</code>，我当时知道<code>触发后的监听代码和触发的代码是在同一线程上执行的</code>，但却回答了是异步，哎，我这逻辑又下降了。。。。</p>

<p>举个栗子，比如说HTTP异步请求返回代码中我们触发一个通知，这个时候在监听的代码中直接去设置视图就会报错，因为当前线程不是主线程，正确的姿态应该是</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
    NSNotificationCenter.defaultCenter().postNotificationName(kNotificationName, object: nil)
})             
</code></pre>

<p>当然你也可以选择另一种方式，<code>NSNotificationQueue</code>通知队列，我们可以通过它做很多基于Runloop的需求，最重要的是它是异步执行的。</p>

<pre><code>let queue = NSNotificationQueue.defaultQueue()
queue.enqueueNotification(NSNotification(name: kNotificationName, object: nil), postingStyle: NSPostingStyle.PostNow)
</code></pre>

<h4 id="toc_0">参考:</h4>

<p><a href="http://www.cnblogs.com/xiaouisme/archive/2012/04/06/2434753.html">cocoa的NSNotification通知</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#技巧2# 强制旋转应用当前屏幕]]></title>
    <link href="https://mokai.me/15136777080114.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/15136777080114.html</id>
    <content type="html"><![CDATA[
<p>经常有这样的需求，APP只需要竖屏，但是一些特殊的场景下需要横屏。</p>

<p>比如说调用系统的<code>MPMovieViewController</code>播放视频时，我们会在AppDelegate中或者UIViewController中更新允许横屏的配置，当播放器旋转到横屏（此时设备应该也是处于横屏），APP现有<code>ViewController</code>也会跟着旋转，那么问题来了，当再次回到APP时，此时现有<code>ViewController</code>是处于横屏的，我们再去代理中更新为竖屏会发现代理根本不会被调用，这时我们就需要用到下面这段代码，去手动触发屏幕旋转事件 </p>

<pre><code>let vc = UIViewController();
self.presentViewController(vc, animated: false, completion: nil)
vc.dismissViewControllerAnimated(false, completion: nil)
</code></pre>

<h4 id="toc_0">参考:</h4>

<p><a href="http://foggry.com/blog/2014/08/08/ping-mu-xuan-zhuan-xue-xi-bi-ji/">iOS屏幕旋转学习笔记</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#技巧1# iOS8以后presendViewController透明效果无效]]></title>
    <link href="https://mokai.me/15136777080398.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/15136777080398.html</id>
    <content type="html"><![CDATA[
<p>iOS弹出的视图背景默认是黑色，如果想去掉，以往我们使用 <code>self.modalPresentationStyle = .CurrentContext</code> 就可以实现效果，如以下半透明的代码</p>

<pre><code>let vc = UIViewController()
vc.view.backgroundColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 0.5)
self.modalPresentationStyle = .CurrentContext
self.presentViewController(vc, animated: true, completion:  nil)
</code></pre>

<p>但是你会发现这段代码在iOS8、iOS9上面运行依旧一片黑，因此iOS8以后得这么干</p>

<pre><code>let vc = UIViewController()
vc.view.backgroundColor = UIColor(red: 0.000 , green: 0.000 , blue: 0.000, alpha: 0.5)
if let version = Float(UIDevice.currentDevice().systemVersion) where version &gt;= 8 {
    vc.modalPresentationStyle = .OverCurrentContext //注意此处是弹出VC对象，不是self
} else {
    self.modalPresentationStyle = .CurrentContext
}
self.presentViewController(vc, animated: true, completion: nil)
</code></pre>

<p>iOS8后增加了<code>OverCurrentContext</code>取代<code>CurrentContext</code>，并且设置的对象是弹出的VC</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS国际化]]></title>
    <link href="https://mokai.me/iOS-i18n.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/iOS-i18n.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Demo同步更新到Swift2.3</p>
</blockquote>

<p>在真正将国际化实践前，只知道通过<code>NSLocalizedString</code>方法将相应语言的字符串加载进来即可。但项目的新需求增加英文版本，并支持应用内无死角切换~，这才跳过各种坑实现了应用内切换语言，并记录至此。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">环境</h3>

<p>系统环境: iOS7 or later<br/>
开发环境: Swift2.3 &amp; Xcode7.3.1<br/>
DEMO: <a href="https://github.com/mokai/LocalDemo">LocalDemo</a></p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_0.gif" alt=""/></p>

<p>这个Demo的功能主要是切换语言后相应的界面文字&amp;图片以及搜索引擎都会随语言变化。我们会围绕这个DEMO进行讲解，读者可以先下载这个Demo运行看下效果再往下</p>

<p><br/></p>

<h3 id="toc_1">iOS国际化原理分析</h3>

<p>国际化其实都大同小异，其核心思想就是<code>为每种语言单独定义一份资源</code>。</p>

<p>iOS就是通过<code>xxx.lproj</code>目录来定义每个语言的资源，这里的资源可以是图片，文本，Storyboard，Xib等。我们可以看看LocalDemo源代码的物理目录结构</p>

<p>Base，暂时无需理会</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_1.png" alt=""/></p>

<p>English</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_1_1.png" alt=""/></p>

<p>中文</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_1_2.png" alt=""/></p>

<p>每种语言都有自己的 <a href="http://www.lingoes.cn/zh/translator/langcode.htm">语言代码</a>.lproj文件夹，加载资源时只需要加载相应语言文件夹下的资源就OK，这步可以系统为我们完成，也可以手动去做。</p>

<blockquote>
<p>项目源代码中如果有多个不同目录的国际化资源，则会有产生多个xxx.lproj，但在编译打包后，会集中放在app的根目录中的xxx.lproj中，不信你看~</p>
</blockquote>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_1_3.png" alt=""/><br/>
<br/></p>

<h3 id="toc_2">开始国际化</h3>

<p>首先点击项目-&gt;PROJECT-&gt;Info-&gt;Localizations中添加要支持的语言</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_2.png" alt=""/></p>

<blockquote>
<p>此处Use Base Internationalization开启状态下，每个国际化资源文件会有个Base选项，主要针对String，Storyboard，Xib作为一个基础的模板，像后述<a href="#storyboard_2">storyboard国际化中方案二</a>就是基于Base StoryBoard进行改动。</p>
</blockquote>

<p>在点击<code>+</code> 添加相应语言时会弹出以下对话框，意思是为现有的资源添加语言文件，我们点击<code>Finish</code>就行了</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_2_1.png" alt=""/></p>

<p><br/></p>

<h3 id="toc_3">文本的国际化</h3>

<p>主要针对代码中的字符串进行国际化，比如说一些消息，UI标题等。</p>

<p>我们通过一个<code>Localizable.strings</code>文件来存储每个语言的文本，它是iOS默认加载的文件，如果想用自定义名称命名，在使用<code>NSLocalizedString</code>方法时指定tableName为自定义名称就好了，但你的应用规模不是很大就不要分模块搞特殊了。</p>

<p>每个资源文件如果想为一种语言添加支持，通过其属性面板中的<code>Localization</code>添加相应语言就行了，此时<code>Localizable.strings</code>处于可展开状态，子级有着相应语言的副本。我们把相应语言的文本放在副本里面就行了</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_3.png" alt=""/></p>

<blockquote>
<p>此处Base与前面提过到的<code>开启Use Base Internationalization</code>是有关联的，只有开启了全局<code>Use Base Internationalization</code>此处才会显示。那为什么这里没有勾选Base？Base做为一个基础模板，作用于Strings文件是没有太大意义的，另外去掉Base意义着在Base.lproj中少了一个strings文件，APP大小也所有下降，这点对于图片的Base更是如此</p>
</blockquote>

<p>在上图可以看到其实就是为每一套语言新建一份strings，其内容采用<code>&quot;key&quot; = &quot;value&quot;;</code>的格式，注意有<code>;</code>号</p>

<p>我们在代码中这样写就行了</p>

<pre><code>NSLocalizedString(&quot;首页&quot;,comment: &quot;&quot;)
NSLocalizedString(&quot;好友&quot;,comment: &quot;&quot;)
NSLocalizedString(&quot;我&quot;,comment: &quot;&quot;)
</code></pre>

<blockquote>
<p>另外中文strings【Localizable.strings(Simplified)】可以不要的(可以理解为中文为APP的默认语言)，因为key就是value，当找不到相应的语言strings或value时会直接返回key。nice！这样一来我们做文本的国际化就只要维护一个英文副本strings就O了</p>
</blockquote>

<p><br/></p>

<h3 id="toc_4">图片的国际化</h3>

<p>二种方案，通过原生支持与自定义命名</p>

<blockquote>
<p>注意，新版Xcode中Images.xcassets不支持国际化（属性页面中没有<code>Localization</code>），Xcode5以前是支持的</p>
</blockquote>

<ul>
<li><p>方案一：自定义文本命名</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_4.png" alt=""/></p>

<p>利用文本国际化的方式，在代码中调用</p>

<pre><code>UIImage(named: NSLocalizedString(&quot;search_logo&quot;,comment: &quot;&quot;))
</code></pre>

<blockquote>
<p>不推荐，一是因为做法太low了，工作量明显加大。二是不能在Storyboard或XIB中使用</p>
</blockquote></li>
<li><p>方案二：原生支持<br/>
<img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_4_1.png" alt=""/></p>

<blockquote>
<p>同上，Base副本去掉。另外需要注意的是，使用这种方式，在XIB或Storyboard中引用图片时如果只使用名称是实时显示不了的，一定要加上后缀名。如avater.png</p>
</blockquote>

<p>使用方式不变，iOS会自动找相应语言(xxx.lproj)下的图片</p>

<pre><code>UIImage(named: &quot;avater&quot;)
</code></pre>

<p>对于图片的放置，正确姿态应该是<code>需要国际化的图片放在自定义Group里面，不需要国际化的图片放在Images.xcassets</code></p></li>
</ul>

<p><br/></p>

<h3 id="toc_5">Storyboard&amp;XIB的国际化</h3>

<p>前面的两种资源国际化比较简单，但Storyboard国际化就稍微麻烦了点。同样它也有二种方案</p>

<ul>
<li><p>方案一：每种语言定制一套Storyboard</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_5.png" alt=""/></p>

<p>在上图我们可以看到，每种语言都可以切换为strings或Storyboard（默认为strings）。如果选用<code>Interface Builder Storyboard</code>方案，那么每种语言都有一套相应的Storyboard，各个语言Storyboard间的界面改动不关联</p></li>
<li><p>方案二：基于基础的<code>Base StoryBoard</code>以及每种语言一套strings <a id='storyboard_2'></a></p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_5_1.png" alt=""/></p>

<p>基于一个基础的Storyboard，可以看作是一个基础的模板，Storyboard里面所有的文本类资源(如UILabel的text)都会被放在相应语言的strings里面。此时我们为Storyboard里的字符类资源作国际化只需要编辑相应语言的strings就行了</p></li>
</ul>

<p>首选方案二。因为采用方案一，意义着你每改动一个界面元素就得去相应语言Storyboard一一改动，那跟为每个语言新起一个项目是一样的道理。但是采用方案二，我们只需改动Base Storyboard就行了</p>

<blockquote>
<p>注意，方案二中相应语言的strings一旦生成后，Base Storyboard有任何编辑都不会影响到strings，这就意味着如果我们删除或添加了一个UILabel的text，strings也不能同步改动</p>
</blockquote>

<p>还好，Xcode为我们提供了<code>ibtool</code>工具来生成Storyboard的strings文件。</p>

<pre><code>ibtool Main.storyboard --generate-strings-file ./NewTemp.string
</code></pre>

<p>但是ibtool生成的strings文件是BaseStoryboard的strings(默认语言的strings)，且会把我们原来的strings替换掉。所以我们要做的就是把新生成的strings与旧的strings进行冲突处理(新的附加上，删除掉的注释掉)，这一切可以用这个pythoy脚本来实现，见<a href="https://raw.githubusercontent.com/mokai/iOS-i18n/master/i18n/RunScript/AutoGenStrings.py">AutoGenStrings.py</a>。然后我们将借助<code>Xcode 中 Run Script</code>来运行这段脚本。这样每次Build时都会保证语言strings与Base Storyboard保持一致</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_5_2.png" alt=""/></p>

<p><br/></p>

<h3 id="toc_6">应用内切换语言</h3>

<p>应用启动时，首先会读取NSUserDefaults中的key为<code>AppleLanguages</code>的内容，该key返回一个String数组，存储着APP支持的语言列表，数组的第一项为APP当前默认的语言。</p>

<p>在安装后第一次打开APP时，会自动初始化该key为当前系统的语言编码，如简体中文就是zh-Hans。</p>

<pre><code>//获取APP当前语言
(NSUserDefaults.standardUserDefaults().valueForKey(&quot;AppleLanguages&quot;) as! Array&lt;String&gt;)[0]
</code></pre>

<p>那么我们要实现语言切换改变<code>AppleLanguages</code>的值即可，但是这里有一个坑，因为苹果没提供给我们直接修改APP默认语言的API，我们只能通过NSUserDefaults手动去操作，且<code>AppleLanguages</code>的值改变后APP得重新启动后才会生效（才会读取相应语言的lproj中的资源，意义着就算你改了，资源还是加载的APP启动时lproj中的资源），猜测应该是框架层在第一次加载时对<code>AppleLanguages</code>的值进行了内存缓冲</p>

<pre><code>//设置APP当前语言
var def = NSUserDefaults.standardUserDefaults()
def.setValue([“zh-Hans”], forKey:&quot;AppleLanguages&quot;)
def.synchronize()
</code></pre>

<p>那么问题来了，如何做到改变<code>AppleLanguages</code>的值就加载相应语言的lproj资源？</p>

<p>其实，APP中的资源加载（Storyboard、图片、字符串）都是在<code>NSBundle.mainBundle()</code>上操作的，那么我们只要在语言切换后把<code>NSBundle.mainBundle()</code>替换成当前语言的bundle就行了，这样系统通过<code>NSBundle.mainBundle()</code>去加载资源时实则是加载的当前语言bundle中的资源</p>

<blockquote>
<p>lproj目录可以用一个NSBundle表示</p>
</blockquote>

<pre><code>import Foundation

/**
*  当调用onLanguage后替换掉mainBundle为当前语言的bundle
*/
private let _bundle:UnsafePointer&lt;Void&gt; =  unsafeBitCast(0,UnsafePointer&lt;Void&gt;.self)
class BundleEx: NSBundle {
    override func localizedStringForKey(key: String, value: String?, table tableName: String?) -&gt; String {
        if let bundle = languageBundle() {
            return bundle.localizedStringForKey(key, value: value, table: tableName)
        }else{
            return super.localizedStringForKey(key, value: value, table: tableName)
        }
    }
}

extension NSBundle {
    private struct Static {
        static var onceToken : dispatch_once_t = 0
    }
    func onLanguage(){
        //替换NSBundle.mainBundle()为自定义的BundleEx
        dispatch_once(&amp;Static.onceToken) {
            object_setClass(NSBundle.mainBundle(), BundleEx.self)
        }
    }
    
    //当前语言的bundle
    func languageBundle()-&gt;NSBundle?{
        return Languager.standardLanguager().currentLanguageBundle
    }
}
</code></pre>

<h3 id="toc_7">其他</h3>

<ul>
<li><p>设置运行语言环境</p>

<p>有时我们第一次安装APP时不想默认跟随系统，那么可以通过Xcode的scheme来指定特定语言</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_6.png" alt=""/></p></li>
<li><p>Storyboard实时预览</p>

<p>直接上图~</p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_6_1.png" alt=""/></p></li>
<li><p>IB中UIImageView国际化无效</p>

<p>解决办法就是为<code>UIImageView</code>扩展一个方法，然后通过IB中的<code>User Defined Runtime Attributes</code>把imageName传进去</p>

<pre><code>extension UIImageView{
  var local: String {
      get{
          return &quot;&quot;
      }
      set(newlocal) {
          self.image = localizedImage(newlocal)
      }
  }
}
</code></pre>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_6_2.png" alt=""/></p></li>
<li><p>IB中UITextView国际化无效</p>

<p>解决办法和UIImageView类似，扩展一个方法，然后把self.text做为key去strings文件中拿相应语言的value</p>

<pre><code>extension UITextView {
  var local: Bool {
      get{
          return true
      }
      set(newlocale) {
          self.text = localized(self.text)
      }
  }
}
</code></pre>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/locale_6_3.png" alt=""/></p></li>
<li><p>LaunchScreen.xib的国际化</p>

<p>很遗憾，到目前为止，还不支持LaunchScreen.xib的国际化，我们只能通过自定义一个LaunchViewController来完成此需求，但也有些不足，就是应用启动时会黑屏一段时间，所以建议启动页面不要弄国际化</p></li>
</ul>

<h3 id="toc_8">参考</h3>

<ul>
<li><a href="http://www.cnblogs.com/levilinxi/p/4296712.html">iOS国际化——通过脚本使storyboard翻译自增</a></li>
<li><a href="https://medium.com/ios-apprentice/working-with-localization-905e4052b9de">Working with Localization</a></li>
<li><a href="http://stackoverflow.com/questions/1669645/how-to-force-nslocalizedstring-to-use-a-specific-language">How to force NSLocalizedString to use a specific language</a></li>
</ul>

<h3 id="toc_9">小小广告</h3>

<p>本人目前是一名自由职业者，接受移动两端的项目开发，如果你有需求或者有资源请速与我联系吧，QQ865425695</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[蓝牙编程]]></title>
    <link href="https://mokai.me/bluetooth-guide.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/bluetooth-guide.html</id>
    <content type="html"><![CDATA[
<p>蓝牙技术，很早以前就被有了，如今已更新4.0版本。很多热门技术都是基于它工作的，如Android平台的NFC，iOS的iBeancon，Apple Watch的WatchConnectivity框架等，现在的智能家居基本也是基于蓝牙4.0与APP进行通信，可见蓝牙在实践工作中的重要性。在iOS中，蓝牙是基于4.0标准的，设备间低功耗通信。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_0">核心成员</h3>

<p>在开始前我们回忆下传统的Socket编程，里面有Server服务端与Client端的区别。那么在蓝牙编程也是如此，其中<code>Peripheral</code>外设相当于Socket编程中的Server服务端，<code>Central</code>中心相当于Client客户端(ps吐槽下，Central中心，作为服务端，不更适合吗！)</p>

<p><img src = "https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBDevices1_2x.png" width=600 height=400 /></p>

<p>你可以理解外设是一个广播数据的设备，它开始告诉外面的世界说它这儿有一些数据，并且能提供一些服务。另一边中心开始扫描周边有没有合适的设备，如果发现后，会和外设做连接请求，一旦连接确定后，两个设备就可以传输数据了。</p>

<p>在iOS6之后，iOS 设备可以是外设，也可以是中心，就像Socket编程中一样，你可以是服务端也可以是客户端。</p>

<h4 id="toc_1">服务(service)和特征(characteristic)</h4>

<p>每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。特征是与外界交互的最小单位。比如说，智能音响设备，用服务A标识播放模块，特征A1来表示播放上一首，特征A2来表示播放下一首；服务B标识设置模块，特征B1设置彩灯颜色。这样做的目的主要为了<code>模块化</code>。</p>

<blockquote>
<p>外设，服务，特征都有一个<code>UUID</code>来标识</p>
</blockquote>

<p>上面说了设备可以是外设，也可以是中心，也就是会有二种模式  </p>

<ul>
<li>本地中心 -&gt; 远程外设<br/></li>
<li>本地外设 -&gt; 远程中心 </li>
</ul>

<p>不过在智能家居开发中，大部分硬件蓝牙都是担任外设的角色，也就是说我们应用只要扮演中心即可了。</p>

<h3 id="toc_2">开始</h3>

<p>本篇只讲述第一种模式的本地中心，远程外设端可借助 <del><a href="https://itunes.apple.com/cn/app/lightblue/id639944780?mt=12">蓝牙调试神器LightBlue For Mac</a></del>。需要了解第二种模式可以移步<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/PerformingCommonPeripheralRoleTasks/PerformingCommonPeripheralRoleTasks.html#//apple_ref/doc/uid/TP40013257-CH4-SW1">创建外设</a> </p>

<blockquote>
<p>更新：LightBlue For Mac只可以做为Central，不可以做为Peripheral，如需模拟请下载<a href="https://itunes.apple.com/cn/app/lightblue-explorer-bluetooth/id557428110?mt=8">iOS版本</a></p>
</blockquote>

<p>蓝牙交互的流程大致为</p>

<blockquote>
<p>建立中心角色 —&gt; 扫描外设（discover）—&gt; 发现外设后连接外设(connect) —&gt; 扫描外设中的服务和特征(discover) —&gt; 与外设做数据交互(explore and interact) —&gt; 断开连接(disconnect)。</p>
</blockquote>

<p>下面我们一一讲到</p>

<h3 id="toc_3">建立中心角色</h3>

<p>在本地中心角色中，使用CBCentralManager类管理，我们创建一个CBCentralManager类</p>

<pre><code>let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
let centralMgr = CBCentralManager(delegate: self, queue: queue)
</code></pre>

<p>上面的delegate为CBCentralManagerDelegate，后续蓝牙相关的回调都会在此。Queue代表蓝牙在哪个队列里面操作，如果传入nil默认为主队列，值得注意的是后续的回调也是在传入的队列中调用的，所以如果传入的是非主线程的队列，在delegate中需要操作UI时需要手动切换到主线程</p>

<p>CBCentralManager对象创建后会回调到<code>centralManagerDidUpdateState</code>方法来检测蓝牙可用状态，这时我们可以提醒用户设备是否支持蓝牙，是否打开了蓝牙</p>

<h3 id="toc_4">扫描外设</h3>

<pre><code>let serviceUUIDS: Array&lt;CBUUID&gt; = [CBUUID(string: &quot;FFDD&quot;)]
self.centralMgr.scanForPeripheralsWithServices(serviceUUIDS, options: [CBCentralManagerScanOptionAllowDuplicatesKey : true])

//停止扫描
self.centralMgr.stopScan()
</code></pre>

<p>如果serviceUUIDS为nil则会扫描周围所有的设外设，否则只会扫描UUID匹配的外设。CBCentralManagerScanOptionAllowDuplicatesKey默认为false，表示扫描中发现过设备则跳过不回调，我们这里传入true，因为下面做外设掉线的处理时需要用到</p>

<blockquote>
<p>传入的serviceUUIDS数组元素为CBUUID类型，千万不要传入String，后面的操作也是如此，不然会碰到很多奇葩问题</p>
</blockquote>

<p>发现外设后会回调到<code>centralManager(central:didDiscoverPeripheral:advertisementData:RSSI:)</code> ，perpheral则代表着外设，我们需要保存起来，后续的对外设的操作都是基于perpheral对象的</p>

<pre><code>func centralManager(central: CBCentralManager!, didDiscoverPeripheral peripheral: CBPeripheral!, advertisementData: [NSObject : AnyObject]!, RSSI: NSNumber!) {
   for i in 0..&lt;discoveredPeripheralers.count {
       var peripheraler = discoveredPeripheralers[i]
       if(!peripheral.identifier.isEqual(peripheraler.peripheral.identifier)){ //未发现过才保存
          discoveredPeripheralers.append(peripheraler)
       }
   }
}
</code></pre>

<h3 id="toc_5">连接外设</h3>

<pre><code>self.centralMgr.connectPeripheral(peripheral, options: nil)
</code></pre>

<p>传入上面保存的外设对象，如果连接失败后会回调到 <code>centralManager(central:didFailToConnectPeripheral:error:)</code>，连接成功后会回调到 <code>centralManager(central:didConnectPeripheral:)</code>，这个时候我们只是连接上外设而已，还需要发现外设中的服务与特征</p>

<h3 id="toc_6">发现服务与特征</h3>

<p>外设连接成功后我们把peripheral保存好，并设置好peripheral的delegate(CBPeripheralDelegate)，然后调用discoverServices来发现服务，同扫描外设时一样，discoverServices也可以传入一个serviceUUIDs参数来只获取需要的服务</p>

<blockquote>
<p>注意，注意，注意，重要的话说三遍。以下的回调都是CBPeripheralDelegate的了，不再是CBCentralManagerDelegate的回调</p>
</blockquote>

<pre><code>func centralManager(central: CBCentralManager!, didConnectPeripheral peripheral: CBPeripheral!) {
    self.peripheral = peripheral
    self.peripheral.delegate = self
    let serviceUUIDS: Array&lt;CBUUID&gt; = [CBUUID(string: &quot;FF12&quot;)]
    self.peripheral.discoverServices(serviceUUIDS)
}
</code></pre>

<p>发现服务后回调到<code>peripheral(peripheral:didDiscoverServices:)</code>，这时我们就可以访问所有发现的服务一一去发现服务下的特征</p>

<pre><code>func peripheral(peripheral: CBPeripheral!, didDiscoverServices error: NSError!) {
    if(error != nil) {
        log(error)
        return
    }
    for item in peripheral.services {
        let service = item as! CBService
        let characteristicUUIDs: Array&lt;CBUUID&gt; = [CBUUID(string: &quot;FF02&quot;), CBUUID(string: &quot;FF04&quot;)]
        peripheral.discoverCharacteristics(characteristicUUIDs, forService: service)  //发现特征
    }
}
</code></pre>

<p>同样特征也可以传入characteristicUUIDs数组来过滤，发现特征后回调</p>

<pre><code>func peripheral(peripheral: CBPeripheral!, didDiscoverCharacteristicsForService service: CBService!, error: NSError!) {
    if(error != nil){
        log(error)
        return
    }
    for item in service.characteristics {
        let characteristic = item as! CBCharacteristic
        if(characteristic.properties == .Notify) { //如果特征为订阅属性则开启订阅
            peripheral.setNotifyValue(true, forCharacteristic: characteristic)
        }
    }
}
</code></pre>

<p>每进入一次回调代表发现一个服务中的特征而不是外设所有的特征，外设、服务、特征从左至右都是上下级一对多的关系。<br/>
每个特征都有个属性，代表着它是可写、可读等，一个特征可同时拥有读写权限，如上面的订阅其实是一种订阅者模式的读取数据</p>

<h3 id="toc_7">发送数据</h3>

<p>拿到可写的特征后，通过writeValue发送数据包</p>

<pre><code>let data = &quot;hello&quot;.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)
//自动判断写特征的类型
var type: CBCharacteristicWriteType = .WithoutResponse
if(writeCharacteristic.properties == CBCharacteristicProperties.Write) {
    type = .WithResponse
}
self.peripheral!.writeValue(data, forCharacteristic: writeCharacteristic, type: type)

</code></pre>

<p>把要发送的文本转换为二进制，发送到相应的特征即可。值得注意的是第三个参数type写类型需要与特征的属性一致，其中WithoutResponse与WithResponse区别在于前者发送数据后是没有回调的，后者会回调到  <code>peripheral(peripheral:didWriteValueForCharacteristic:error:)</code> 来检测是否发送成功，如果发送数据传入的类型与特征不同时总是会失败</p>

<blockquote>
<p>由于蓝牙的缓冲大小只有20bytes，那么如果我们发送的数据包大小不能大于20bytes，所以得分多次发送</p>
</blockquote>

<pre><code>func writeValue(data: NSData, withCharacteristic characteristic: CBCharacteristic) -&gt; Bool {
    if(self.peripheral == nil) {
        return false
    }
    var didSend = false
    var sendDataIndex = 0
    let  NOTIFY_MTU = 20
    while (data.length - sendDataIndex != 0) {
        //剩下的数据大小
        var amountToSend = data.length - sendDataIndex
        // 不能大于20bytes
        if (amountToSend &gt; NOTIFY_MTU) {
            amountToSend = NOTIFY_MTU
        }
        let chunk = NSData(bytes: data.bytes + sendDataIndex, length: amountToSend)
        var type: CBCharacteristicWriteType = .WithoutResponse
        if(characteristic.properties == CBCharacteristicProperties.Write) {
            type = .WithResponse
        }
        self.peripheral!.writeValue(chunk, forCharacteristic: characteristic, type: type)
        sendDataIndex += amountToSend
    }
    return true
}
</code></pre>

<h3 id="toc_8">读取数据</h3>

<p>分为二种，直接读、订阅，顾名思义，直接读就是手动调用API读取，订阅则只要开启后，外设有消息都可以收到</p>

<p>直接读</p>

<pre><code>self.peripheral!.readValueForCharacteristic(characteristic)
</code></pre>

<p>订阅</p>

<pre><code>self.peripheral!.setNotifyValue(true, forCharacteristic: characteristic)
</code></pre>

<p>两种回调都会回调到 <code>peripheral(peripheral:didUpdateValueForCharacteristic:error:)</code>，上面也提到因为蓝牙的缓冲大小，需要发送多次，那么在读取时也需要接收多次，才能保证数据的一体性，所以通常都会在数据包的开始用 <code>EOM</code> 来标识一段数据的开始，数据结束后再次用 <code>EOM</code> 来标识，所以我们接收数据时会这样</p>

<pre><code>let updatingEOMFlag = &quot;EOM&quot;
func peripheral(peripheral: CBPeripheral!, didUpdateValueForCharacteristic characteristic: CBCharacteristic!, error: NSError!) {
    if(error != nil) {
        log(error)
        return
    }
    if(characteristic.value != nil) {
        var data = characteristic.value!
        var string = NSString(data: data, encoding: NSUTF8StringEncoding)
        log(string)
        
        //接收多段数据
        if(self.updatingEOMFlag != nil) {
            if(self.updatingEOMFlag == string) {
                var EOMEndFlag = false
                for i in 0..&lt;self.updatingDatas.count { //数据结束
                    var updatingData = self.updatingDatas[i]
                    if(updatingData.characteristic.UUID.isEqual(characteristic.UUID)) {
                        data = updatingData.data
                        string = NSString(data: data, encoding: NSUTF8StringEncoding)
                        self.updatingDatas.removeAtIndex(i) //删除缓存数据
                        EOMEndFlag = true
                        break
                    }
                }
                if(!EOMEndFlag) {//数据开始
                    let updatingData = UpdatingDataer(characteristic: characteristic, data: NSMutableData())
                    self.updatingDatas!.append(updatingData)
                    return
                }
            } else {
                if var updatingData = (self.updatingDatas?.filter{ $0.characteristic.UUID.isEqual(characteristic.UUID) }) where updatingData.count == 1 &amp;&amp; updatingData[0].data != nil { //数据中间
                    updatingData[0].data.appendData(data)
                    return
                }
            }
        }
        //在此最终得到完整数据
        let stringData = StringData(string: string as? String, data: data)

        //触发delegate与通知回调
        ...
    }
}
</code></pre>

<h3 id="toc_9">断开连接</h3>

<pre><code>self.centralMgr.cancelPeripheralConnection(self.peripheral!)
</code></pre>

<p>至此，整个流程就完了</p>

<h3 id="toc_10">高级需求~</h3>

<h4 id="toc_11">外设掉线检测</h4>

<p>所谓掉线就是外设发现了后，过了一段时间失去信号了。喵了下系统框架，没有找到相关外设掉线的检测，唯一有点像的就是发现外设里面的RSSI,代表设备信号强度，值越小信息越好。</p>

<h3 id="toc_12">总结</h3>

<ul>
<li>在蓝牙交互的二种角色中，通常APP端扮演<code>中央Central</code>的角色，设备扮演<code>外设Peripheral</code>的角色</li>
<li>创建CBCentralManager对象时传入的Queue决定了后续CBCentralManagerDelegate、CBPeripheralDelegate等回调的所在线程</li>
<li>一个外设设备可包含一个或多个服务，一个服务可包含一个或多个特征，读写操作最终是针对特征。</li>
<li>蓝牙的缓冲大小只有20bytes，在发送数据时最多只能发送20bytes，所以得分多次发送，数据的一体性可以用 EOM 标识符表标识</li>
</ul>

<blockquote>
<p>更新: 提供了一个读写的<a href="https://github.com/mokai/BluetoothDemos">Central端Demo</a>，Peripheral端请用上述iOS版LightBlue模拟</p>
</blockquote>

<h3 id="toc_13">参考</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth Programming Guide</a></p>

<p><a href="http://www.jianshu.com/p/760f042a1d81">译-iOS蓝牙编程指南</a></p>

<h3 id="toc_14">小小广告</h3>

<p>本人目前是一名自由职业者，接受移动两端的项目开发，如果你有需求或者有资源请速与我联系吧，QQ865425695</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IB中Runtime Attributes个别属性无效]]></title>
    <link href="https://mokai.me/15136777080294.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/15136777080294.html</id>
    <content type="html"><![CDATA[
<p>在使用Xcode IB方式编码中，经常会使用到属性列表中没有的属性，这时则需要通过<code>Runtime Attributes</code>来动态注入(实则为<code>KVO</code>实现)</p>

<span id="more"></span><!-- more -->

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/2015-04-07_1.png" alt=""/></p>

<p>但有个别属性设置你会发现怎样都无效</p>

<p>如：<code>layer.borderColor</code></p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/2015-04-07_2.png" alt=""/></p>

<p>原因在于<code>borderColor</code>接受的参数是CGColor类型，而此处的Color为UIColor，所以导致注入时参数类型不一致</p>

<h3 id="toc_0">解决方案：利用扩展自定义一个<code>中间属性器</code>来转换一下类型就OK了</h3>

<p>1、自定义代码</p>

<pre><code>extension CALayer{
    //解决IB中runtime attribute中layer.borderColor不能转换UIColor为CGColor
    var borderColorFromUIColor: UIColor {
        set(color){
            self.borderColor = color.CGColor;
        }
        get{
            return UIColor(CGColor: self.borderColor)
        }
    }
}
</code></pre>

<blockquote>
<p>注意,swift与OC的属性设置器不同，OC中是setXXX，而swift是有内部setter</p>
</blockquote>

<p>2、IB中设置，把原先的<code>layer.borderColor</code>改为<code>layer.borderColorFromUIColor</code></p>

<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/2015-04-07_3.png" alt=""/></p>

<p>参考:<br/>
<a href="http://ios-blog.co.uk/tutorials/user-defined-runtime-attributes/">User Defined Runtime Attributes</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello]]></title>
    <link href="https://mokai.me/hello.html"/>
    <updated>2017-12-19T18:01:48+08:00</updated>
    <id>https://mokai.me/hello.html</id>
    <content type="html"><![CDATA[
<p><img src="http://7xiew0.com1.z0.glb.clouddn.com/2015-04-01-hello_just_do_it.jpg" alt=""/></p>

<p>Hello，new Blog~</p>

<p>之前一直都是在<a href="http://blog.csdn.net/VictorMoKai">csdn</a>上写博客(其实也没怎么写(⊙o⊙)…)，最近订了些目标，个人网站就是其中一项</p>

<p>so~ Just do it!</p>

]]></content>
  </entry>
  
</feed>
